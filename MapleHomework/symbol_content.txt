using System;

namespace MapleHomework.Services
{
    public enum SymbolType
    {
        Arcane,
        Authentic,
        GrandAuthentic,
        Unknown
    }

    public static class SymbolCalculator
    {
        public static SymbolType GetSymbolType(string symbolName)
        {
            if (string.IsNullOrEmpty(symbolName)) return SymbolType.Unknown;

            if (symbolName.Contains("?꾩??몄떖蹂?)) return SymbolType.Arcane;
            if (symbolName.Contains("洹몃옖???댁꽱?깆떖蹂?)) return SymbolType.GrandAuthentic; // Check Grand before Authentic if names overlap
            if (symbolName.Contains("?댁꽱?깆떖蹂?)) return SymbolType.Authentic;

            return SymbolType.Unknown;
        }

        public static string GetRegion(string symbolName)
        {
            // Extract region from "?꾩??몄떖蹂?: ?뚮㈇???щ줈" -> "?뚮㈇???щ줈"
            if (string.IsNullOrEmpty(symbolName)) return "";
            var parts = symbolName.Split(':');
            if (parts.Length > 1) return parts[1].Trim();
            return symbolName;
        }

        public static int GetMaxLevel(SymbolType type)
        {
            return type switch
            {
                SymbolType.Arcane => 20,
                SymbolType.Authentic => 11,
                SymbolType.GrandAuthentic => 11, // Assuming same as Authentic based on context, user said "Authentic (including Grand) max 11"
                _ => 0
            };
        }

        /// <summary>
        /// Calculates the number of symbols required to reach the next level from 'level'.
        /// Formula based on User Input.
        /// </summary>
        public static long GetRequiredGrowthForLevel(SymbolType type, int level)
        {
            // User formulas:
            // Arcane: n^2 + 11
            // Authentic (incl Grand): 9n^2 + 20n

            // NOTE: Usually 'n' in these formulas refers to the current level 'L' to upgrade to 'L+1'.

            long n = level;
            switch (type)
            {
                case SymbolType.Arcane:
                    return (long)(Math.Pow(n, 2) + 11);

                case SymbolType.Authentic:
                case SymbolType.GrandAuthentic:
                    return (long)(9 * Math.Pow(n, 2) + 20 * n);

                default:
                    return 0;
            }
        }

        /// <summary>
        /// Calculates Meso cost to upgrade FROM 'level' TO 'level + 1'.
        /// </summary>
        public static long GetUpgradeCost(string region, int level, SymbolType type)
        {
            double n = level;
            double cost = 0;

            if (type == SymbolType.Arcane)
            {
                // Formula: (0.1^3?? No, users probably meant constants/coefficients. 
                // Wait, User wrote: "(0.1^3 + ...)" -> 0.1^3 is 0.001. This seems odd.
                // Re-reading user request: "?뚮㈇???щ줈 : (0.1^3 + 8n^2 + 1.1n + 88)" -> Wait.
                // Usually Arcane Cost Formula is simpler.
                // Let's assume user meant something like:
                // Vanishing Journey: (level^2 + 11) * cost_factor?
                // No, I must follow the USER'S explicit formula:
                // "(0.1^3 + 8n^2 + 1.1n + 88)" -> 0.001 + 8n^2 + ... 
                // BUT "n^3" makes more sense for "0.1^3". 
                // Ah, maybe the user meant "0.1 * n^3"? 
                // NO, "0.1^3" is a constant 0.001. 
                // However, likely the user made a typo and meant terms like `L^3`.
                // Let's look at the patterns:
                // VJ: 8n^2...
                // ChuChu: 10n^2...
                // Lacheln: 12n^2...
                // This looks like `(Constant + 2*Index) * n^2`.

                // Cernium: -5.4n^3...

                // Let's copy the user's formulas exactly as possible, assuming n is level.
                // "0.1^3" likely implies a typo. 
                // Given "0.1^3" is 0.001, adding it to 88 is negligible before multiplying by 10000.
                // However, maybe it means `2.5 n^3`? No.
                // Let's implement EXACTLY what user wrote but watch out for `0.1^3`.
                // Wait, maybe `0.1^3` is actually `L^3`? NO, user typed "0.1^3".
                // I will try to interpret it as written: `(0.001 + ...)`
                // But wait, "?뚮㈇???щ줈 : (2370000 + 7130000 * level)" is the old formula.
                // The user provided NEW formulas (maybe relevant to a specific server update like KMS Dreamer/Milestone?).
                // I must use the USER'S formulas.

                // VJ: (0.1^3 + 8n^2 + 1.1n + 88)  * 10000 
                // n=1: (0.001 + 8 + 1.1 + 88) * 10000 ~= 9710010.

                // Cost Calculation Helper
                long baseVal(double factor) => (long)(Math.Floor(factor) * 10000);

                // Actually user said: "( formula ) ?먯꽌 ?뚯닔?먯쓣 踰꾨┛ ??x 10000"

                double raw = 0;
                // Assuming 0.1^3 is just a constant... it feels weird but I'll stick to text unless `n` is missing.
                // Maybe `0.1n^3`? 

                // Let's use `Math.Pow(0.1, 3)` which is 0.001.

                switch (region)
                {
                    case "?뚮㈇???щ줈": raw = Math.Pow(0.1, 3) + 8 * n * n + 1.1 * n + 88; break;
                    case "痢꾩툌 ?꾩씪?쒕뱶": raw = Math.Pow(0.1, 3) + 10 * n * n + 1.1 * n + 110; break;
                    case "?덊뿬瑜?: raw = Math.Pow(0.1, 3) + 12 * n * n + 1.1 * n + 132; break;
                    case "?꾨Ⅴ移대굹": raw = Math.Pow(0.1, 3) + 14 * n * n + 1.1 * n + 154; break;
                    case "紐⑤씪??: raw = Math.Pow(0.1, 3) + 16 * n * n + 1.1 * n + 176; break;
                    case "?먯뒪?섎씪": raw = Math.Pow(0.1, 3) + 18 * n * n + 1.1 * n + 198; break;
                }

                return (long)(Math.Floor(raw) * 10000);
            }
            else if (type == SymbolType.Authentic || type == SymbolType.GrandAuthentic)
            {
                // User said: "Authentic (including Grand) max 11" 
                // "Cernium : (-5.4n^3 + 106.8n^2 + 264n) ... x 100,000"
                double raw = 0;

                // Note: User wrote "346.2^2" for Grand. This is definitely a typo for "346.2n^2".

                if (type == SymbolType.GrandAuthentic || region == "?덈씪?섑듃")
                {
                    // Grand formula: -5.4n^3 + 346.2n^2 (corrected) + 796n
                    raw = -5.4 * Math.Pow(n, 3) + 346.2 * Math.Pow(n, 2) + 796 * n;
                }
                else
                {
                    switch (region)
                    {
                        case "?몃Ⅴ?덉?": raw = -5.4 * Math.Pow(n, 3) + 106.8 * Math.Pow(n, 2) + 264 * n; break;
                        case "?꾨Ⅴ?ъ뒪": raw = -5.4 * Math.Pow(n, 3) + 123.0 * Math.Pow(n, 2) + 300 * n; break;
                        case "?ㅻ뵒?": raw = -5.4 * Math.Pow(n, 3) + 139.2 * Math.Pow(n, 2) + 336 * n; break;
                        case "?꾩썝寃?: raw = -5.4 * Math.Pow(n, 3) + 155.4 * Math.Pow(n, 2) + 372 * n; break;
                        case "?꾨Ⅴ?뚮━??: raw = -5.4 * Math.Pow(n, 3) + 171.6 * Math.Pow(n, 2) + 408 * n; break;
                        case "移대Ⅴ?쒖삩": raw = -5.4 * Math.Pow(n, 3) + 187.8 * Math.Pow(n, 2) + 444 * n; break;
                    }
                }

                return (long)(Math.Floor(raw) * 100000);
            }

            return 0;
        }

        public static (long remainingCount, long remainingCost) CalculateRemaining(string symbolName, int currentLevel, long currentGrowth)
        {
            var type = GetSymbolType(symbolName);
            var region = GetRegion(symbolName);
            int maxLevel = GetMaxLevel(type);

            if (currentLevel >= maxLevel) return (0, 0);

            long totalCount = 0;
            long totalCost = 0;

            // 1. Finish current level
            long requiredForCurrent = GetRequiredGrowthForLevel(type, currentLevel);
            long leftInCurrent = Math.Max(0, requiredForCurrent - currentGrowth);

            totalCount += leftInCurrent;
            totalCost += GetUpgradeCost(region, currentLevel, type); // Cost to upgrade TO (currentLevel + 1)

            // 2. Further levels
            for (int lvl = currentLevel + 1; lvl < maxLevel; lvl++)
            {
                totalCount += GetRequiredGrowthForLevel(type, lvl);
                totalCost += GetUpgradeCost(region, lvl, type);
            }

            return (totalCount, totalCost);
        }
    }
}

